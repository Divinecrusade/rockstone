# Часть 1. Код-ревью
--- 

## Условие

**Дано:** фрагмент исходного кода сервера (файл `Client.cpp`).

**Задание:**
* Найти и кратко описать (в 2–3 предложениях) **три участка кода**, которые можно улучшить с точки зрения читаемости, архитектуры или производительности.
* Предложить и реализовать улучшения в **одном** из этих участков кода – в виде патча или отдельного нового файла с исправлениями.

---

## Решение

### 1-й участок кода. Потенциальное нарушение инварианта класса `Client::io != nullptr`

Методы `Client::get_ip() const`, `Client::disconnect() const`, `Client::send(const server::Packet &packet)` используют селектор членов класса (оператор `->`, или оператор указателя на член класса). К примеру тело метода `Client::get_ip() const` выглядит следующим образом:
```C++
auto Client::get_ip() const -> IP
{
	return this->io->get_ip();
}
```
Где инициализация члена `Client::io` происходит в конструкторе:
```C++
Client::Client(IO *io):
	io(io)
{
	this->requests = std::make_shared<Requests>(this);
}
```
Следовательно, нет синтаксической гарантии, что `Client::io` никогда не будет инициализирован `nullptr`. Поэтому следующий код приведёт к возникновению исключения:
```C++
Client cur_client{nullptr};

const auto cur_ip{cur_client.get_ip()}; // runtime error, pointer is null
```

#### 1-й подход. Игнорирование

Если архитектура приложения гарантирует, что аргумент `io` в конструкторе никогда не станет `nullptr`, то можно не вносить изменений.

Однако такое решение противоречит с одной стороны ООП, поскольку образует "неявный контракт" между пользователем и сервисом, а с другой нарушает guideline C++, т.к. синтаксически не выражает намерение программиста. Мы предполагаем, что пользователи класса `Client` "знают" о том, что `io` не должен быть `nullptr`. Это усложнение семантики класса можно допустить только при очень существенных обстоятельствах.

#### 2-й подход. Добавление утверждений

Допустим, текущая логика инварианта правильная, в таком случае стоит добавить утверждение в конструкторе класса и методах, использующих проблемный указатель:
```C++
#include <cassert>

#define ASSERT_CLIENT_IO_IS_NOT_NULL assert(this->io != nullptr);

Client::Client(IO *io):
	io(io)
{
	ASSERT_CLIENT_IO_IS_NOT_NULL

	this->requests = std::make_shared<Requests>(this);
}

auto Client::get_ip() const -> IP
{
	ASSERT_CLIENT_IO_IS_NOT_NULL

	return this->io->get_ip();
}

void Client::disconnect() const
{
	ASSERT_CLIENT_IO_IS_NOT_NULL

	this->io->stop();
}

void Client::send(const server::Packet &packet) const
{
	ASSERT_CLIENT_IO_IS_NOT_NULL

	io->write(packet);
}
```

Метод `assert` реализован так, что вызывает завершение программы при истинности выражение только при условии, что определен флаг DEBUG. Соответственно, в релизной версии программы все вызову функции `assert` будут опущены.

Это позволит отловить во время тестирования возможные разименования пустого указателя и при этом не повлияет на итоговую производительность.


#### 3-й подход. Использование `gsl::not_null<IO*>`

Существует (используемая в том числе Microsoft) библиотека [Guidelines Support Library для C++](https://github.com/Microsoft/GSL), которая немного расширяет функционал C++, добавляя новые возможности для синтаксических проверок ограничений, накладываемых либо предметной областью, либо архитектурой ПО. Она свободно распространяема и состоит только из заголовочных файлов.

Используя GSL можно явно наложить требование на аргумент `io` в конструкторе:

```C++
#include <gsl/gsl>

Client::Client(gsl::not_null<IO*> io):
	io(io)
{
	this->requests = std::make_shared<Requests>(this);
}
```

Это добавляет проверку времени исполнения при инициализации фактического параметра. Если `io == nullptr`, то будет вызвано немедленное завершение работы программы (`std::terminate`).

Такой подход лучше использования утверждений, поскольку он накладывает ограничение на уровне интерфейса (объявлении конструктора).