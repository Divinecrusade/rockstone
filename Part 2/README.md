# Часть 2. Реализация функциональности
---

## Условие

**Задание:**
* Реализовать мини-модуль `TopTracker`, который хранит N последних действий игроков с привязкой ко времени.
* В модуле должны быть реализованы операции: добавление нового действия, удаление старых действий по истечении тайм-аута (очистка "просроченных" записей), и получение текущего списка сохранённых действий.
* Использовать стандартные контейнеры (например, `std::deque`, `std::unordered_map`) – необходимо объяснить выбор тех или иных структур данных.
* Минимизировать внешние зависимости – желательно использовать только стандартную библиотеку C++ и, при необходимости, Boost (например, Boost.Timer/Chrono) для работы со временем.
* Реализовать unit-тесты для разработанного модуля `TopTracker`.
* Код модуля и тестов должен быть написан в **том же стиле**, что и существующие файлы проекта (`Client.cpp/h`), включая соглашения по отступам, именованию и общей архитектуре решения.

---

## Решение

### Некоторые выводы из анализа кода первой части задания

Поскольку данная часть задания требует следования стилю программирования и архитекторному решению, показанных в первой части задании, то считаю разумным озвучить соображения и наблюдения, повлиявшие на выполнение этой части задания.

Разумеется, особых вопросов стиль кода не вызывает (snake case для методов и переменных, pascal case для названий классов, операторные скобки начинаются на новой строке, явное использование ключевого слова `this`, использование табов для оступов с размером 4 пробела и т.д.).

Общее архитектурное решение тоже понятно - максимальная модульность класса, заключающаяся в данном случае в обработке и инкапсуляции соединения игрока с сервером.

Неясным остаётся (видимо, потому что приведён не весь код класса) приватный интерфейс, который не вызывается из публичного. Очевидно, что `Client` - это callback, однако в этом случае неясно как именно используется `Client::on_packet(const server::Packet &packet)`, ведь в конструкторе нет, к примеру, инциализации потока, как-то задействующего приватный интерфейс. Тогда остаётся только то, что в приведённом участке кода отсутствует `friend` объявление метода или класса, где либо асинхронно, либо синхронно вызывается приватный метод.

Это важное допущение, которое я осознанно применил при решении данной части задачи. В частности, поэтому я отдаю предпочтение функциональным требованиям (явно определил их в публичном интерфейсе) *TODO: решение проблемы с приватным интерфейсом*

### Интерфейс мини-модуля `TopTracker`

#### Публичный

По нотации АТД `TopTracker` поддерживает следующие действия:
* `TopTracker(timeout, events_max_count)` - конструктор; параметр `timeout` определяет время (*TODO: в чем, в с., в м. и т.д.*), по истечении которого запись считается "просроченной"; параметр `events_max_count` ограничивает максимальное количество хранимых записей.
* `on_event(event)` - добавляет новое действие в `TopTracker`; параметр `event` агрегирует как id игрока, так и тип действия. 
* `delete_old_events()` - удаляет все сохраненные действия, у который разница текущего времени и сохраненного больше, либо равно `timeout`.
* `get_events()` - возвращает текущий список сохранённых действий.

Сюда следует отнести метод `void send(const server::Packet &packet) const;`, который аналогичен соответствующему методу из класса `Client` первой части задания. Такое решение обусловлено требованием придерживаться приведённой архитектуре.

#### Приватный

Здесь доступен только один метод `on_packet(const server::Packet &packet);`, отвечающий за корректную обработку пакетов. Поскольку классу `TopTracker` не важно, какие действия выполняются, то нет необходимости в специальных методах обработки разных пакетов (действий).

### Структура данных

Каждое действие агрегировано в структуру `ActionEntry`, хранящую следующие данные:
* `uint64_t player_id` - id игрока.
* `ClientEvent::Type event` - действие игрока.
* `std::chrono::steady_clock::time_point` - время, когда было совершено действия.

Как можно догадаться по публичному интерфейсу, был выбран вариант с заданием времени совершения действия в теле метода `on_event(event)`, а не передача его как параметр. Это обуславливается желанием достичь лучшей инкапсуляции и модульности `TopTracker`, не вынуждая пользователей самим передавать время в качестве параметра.

Для упрощения анализа условно разделим все STL контейнеры на два типа: 
1. ordered (`vector`, `deque`, `list`, `set`, `map`, `multiset`, `multimap`) - сохраняют или формируют порядок при вставки элементов.
2. unordered (`unordered_set`, `unordered_map`, `unordered_multiset`, `unordered_multimap`) - не сохраняют и не формируют порядок при вставке элементов.

В общем случае, второй вариант предпочителен из-за использования хеш-таблиц, у которых эффективный доступ *O*(1) и вставка *Θ*(1), но с *O*(n). Однако они не подходят, поскольку не сохраняют порядок вставки, что потребует дополнительных действий при реализации вывода списка сохранённых действий.

Остаётся первый вариант. Здесь можно сразу исключить:
* `map`/`multimap` - отсутствие естественного ключа в хранимых данных;
* `list` - избыточность накладных расходов (из-за указателей для связей узлов), как следствие, низкая кеш-локальность;
* `vector` - затруднено удаление старых элементов. Допустим, в конец вектора поступают новые (по времени) действия. Старые располагаются вначале. В результате, их удаление каждый раз будет приводить к реаллокации в памяти вектора со сложность *O*(n).

Таким образом, остаются `set`/`multiset` и `deque`.

Внутреннее представление `set`/`multiset` использует дерево, которое позволяет ускорить поиск элементов и автоматически сортирует данные. Поэтому вставка элемента имеет сложность *O*(log N)

Кроме того, подход с использованием расчёта времени внутри тела метода `add_event` поддерживает автоматическую "сортировку" элементов.

Поэтому `deque` является наиболее подходящим вариантом. Это, в частности, подтверждается интерфейсом: возможность вставки вперед и удаления с конца. При этом их сложность одинакова - *O*(1)
