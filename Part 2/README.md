# Часть 2. Реализация функциональности
---

## Условие

**Задание:**
* Реализовать мини-модуль `TopTracker`, который хранит N последних действий игроков с привязкой ко времени.
* В модуле должны быть реализованы операции: добавление нового действия, удаление старых действий по истечении тайм-аута (очистка "просроченных" записей), и получение текущего списка сохранённых действий.
* Использовать стандартные контейнеры (например, `std::deque`, `std::unordered_map`) – необходимо объяснить выбор тех или иных структур данных.
* Минимизировать внешние зависимости – желательно использовать только стандартную библиотеку C++ и, при необходимости, Boost (например, Boost.Timer/Chrono) для работы со временем.
* Реализовать unit-тесты для разработанного модуля `TopTracker`.
* Код модуля и тестов должен быть написан в **том же стиле**, что и существующие файлы проекта (`Client.cpp/h`), включая соглашения по отступам, именованию и общей архитектуре решения.

---

## Решение

### Некоторые выводы из анализа кода первой части задания

Поскольку данная часть задания требует следования стилю программирования и архитекторному решению, показанных в первой части задании, то считаю разумным озвучить соображения и наблюдения, повлиявшие на выполнение этой части задания.

Разумеется, особых вопросов стиль кода не вызывает (snake case для методов и переменных, pascal case для названий классов, операторные скобки начинаются на новой строке, явное использование ключевого слова `this`, использование табов для оступов с размером 4 пробела и т.д.).

Общее архитектурное решение тоже понятно - максимальная модульность класса, заключающаяся в данном случае в обработке и инкапсуляции соединения игрока с сервером.

Неясным остаётся (видимо, потому что приведён не весь код класса) приватный интерфейс, который не вызывается из публичного. Очевидно, что `Client` - это callback, однако в этом случае неясно как именно используется `Client::on_packet(const server::Packet &packet)`, ведь в конструкторе нет, к примеру, инциализации потока, как-то задействующего приватный интерфейс. Тогда остаётся только то, что в приведённом участке кода отсутствует `friend` объявление метода или класса, где либо асинхронно, либо синхронно вызывается приватный метод.

Это важное допущение, которое я осознанно применил при решении данной части задачи. В частности, поэтому я отдаю предпочтение функциональным требованиям (явно определил их в публичном интерфейсе). Я предполагаю, что требуемый `TopTracker` на более высоком уровне абстракции, и что он не распарсивает пакеты. В противном случае, мне пришлось бы гадать о структуре пакета, о токенах `ClientEvent` и способе взаимодействия с сетевым протоколом. Ничего из этого не описано и не может быть явно выведено из кода первой части задания (как я это показал на примере публичного и приватного интерфейсов), поэтому, скорее всего, классы "заглушки" и мои предположения имели бы мало общего с реальностью и только бы портили семантику требуемого класса.

### Интерфейс мини-модуля `TopTracker`

По нотации АТД `TopTracker` поддерживает следующие действия:
* `TopTracker(timeout, actions_max_count)` - конструктор; параметр `timeout` определяет время в секуднах, по истечении которого запись считается "просроченной"; параметр `actions_max_count` ограничивает максимальное количество хранимых записей.
* `on_action(player_id, action_type)` - добавляет новое действие в `TopTracker`; параметр `event` агрегирует как id игрока, так и тип действия. 
* `delete_old_actions()` - удаляет все сохраненные действия, у который разница текущего времени и сохраненного больше, либо равно `timeout`.
* `get_actions_view()` - возвращает текущий список сохранённых действий в виде ссылки, без копирования.
* `get_actions_copy()` - возвращает текущий список сохранённых действий в виде копии контейнера.

### Структура данных

Каждое действие агрегировано в структуру `PlayerAction`, хранящую следующие данные:
* `uint64_t player_id` - id игрока.
* `PlayerAction::Type type` - тип действия игрока.
* `std::chrono::steady_clock::time_point time_stamp` - время, когда было совершено действия. Рассчитывается автоматически при создании экземпляра класса.

Для упрощения анализа условно разделим все STL контейнеры на два типа: 
1. ordered (`vector`, `deque`, `list`, `set`, `map`, `multiset`, `multimap`) - сохраняют или формируют порядок при вставки элементов.
2. unordered (`unordered_set`, `unordered_map`, `unordered_multiset`, `unordered_multimap`) - не сохраняют и не формируют порядок при вставке элементов.

В общем случае, второй вариант предпочителен из-за использования хеш-таблиц, у которых эффективный доступ *O*(1) и вставка *Θ*(1), но с *O*(n). Однако они не подходят для текущей задачи, поскольку не сохраняют порядок вставки, что потребует дополнительных действий при реализации вывода списка сохранённых действий.

Рассмотрим первый вариант. Здесь можно сразу исключить:
* `list` - избыточность накладных расходов (из-за указателей для связей узлов), как следствие, низкая кеш-локальность. Невозможность эффективно применять бинарный поиск (см. ниже);
* `vector` - затруднено удаление старых элементов. Допустим, в конец вектора поступают новые (по времени) действия. Старые располагаются вначале. В результате, их удаление каждый раз будет приводить к реаллокации памяти вектора со сложностью *O*(n - k), где k - количество удалённых элементов.

Таким образом, остаются `set`/`multiset`, `map`/`multimap` и `deque`.

Внутреннее представление `set`/`multiset` и `map`/`multimap` использует дерево, которое ускоряет поиск элементов и автоматически сортирует данные. Поэтому вставка элемента имеет сложность *O*(log N). Но это излешняя функциональность при условии, что данные о действиях пользователя сохраняются по мере поступления. Поскольку `PlayerAction` сама региструет время попадания в `TopTracker`, то в случае синхронного вызова `add_action` контейнер будет всегда заполняться действиями от позднего к раннему.

Поэтому `deque` является наиболее подходящим вариантом. У этого контейнера сложность вставки вперед и удаления с конца одинакова - *O*(1). Вдобавок, поскольку массив отсортированный и поддерживает последовательные итераторы, то при нахождении конца подмножества устаревших записей можно использовать двоичный поиск.
